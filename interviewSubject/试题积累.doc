试题积累
将函数 fn 的执行上下文改为 obj 对象 ：
①：function speak(fn, obj) {
  return fn.bind(obj)();
}
②：function speak(fn, obj) {
  return fn.apply(obj, obj);
 }

实现函数 makeClosures，调用之后满足如下条件：
1、返回一个函数数组 result，长度与 arr 相同
2、运行 result 中第 i 个函数，即 result[i]()，结果与 fn(arr[i]) 相同

法①：function makeClosures(arr, fn) {
  var result=[];
   for(var i=0;i<arr.length;i++){
       result[i]=(function(i){
           return function(){
              return fn(arr[i]);   
           }
       })(i)
   }
    return result;
}
法②：
function makeClosures(arr, fn) {
    var funcs = [];
arr.forEach(function(item, index){
        var func = function(){
            return fn(item);
        }
        funcs.push(func);
    });
    return funcs;
}
输入例子:
var arr = [1, 2, 3]; var square = function (x) { return x * x; }; var funcs = makeClosures(arr, square); funcs[1]();


输出例子:
4
题目描述
已知 fn 为一个预定义函数，实现函数 curryIt，调用之后满足如下条件：
1、返回一个函数 a，a 的 length 属性值为 1（即显式声明 a 接收一个参数）
2、调用 a 之后，返回一个函数 b, b 的 length 属性值为 1
3、调用 b 之后，返回一个函数 c, c 的 length 属性值为 1
4、调用 c 之后，返回的结果与调用 fn 的返回值一致
5、fn 的参数依次为函数 a, b, c 的调用参数 
解释： 柯里化是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。简单理解题目意思，就是指，我们将预定义的函数的参数逐一传入到curryIt中，当参数全部传入之后，就执行预定义函数。于是，我们首先要获得预定义函数的参数个数fn.length，然后声明一个空数组去存放这些参数。返回一个匿名函数接收参数并执行，当参数个数小于fn.length，则再次返回该匿名函数，继续接收参数并执行，直至参数个数等于fn.length。最后，调用apply执行预定义函数
function curryIt(fn) {
     //获取fn参数的数量
     var n = fn.length;
     //声明一个数组args
     var args = [];
     //返回一个匿名函数
     return function(arg){
         //将curryIt后面括号中的参数放入数组
         args.push(arg);
         //如果args中的参数个数小于fn函数的参数个数，
         //则执行arguments.callee（其作用是引用当前正在执行的函数，这里是返回的当前匿名函数）。
         //否则，返回fn的调用结果
         if(args.length < n){
            return arguments.callee;
         }else return fn.apply("",args);
     }
 }

获取数字 num 二进制形式第 bit 位的值。注意：
1、bit 从 1 开始
2、返回 0 或 1
3、举例：2 的二进制为 10，第 1 位为 0，第 2 位为 1 

通过num.toString(2)能直接将num转换为2进制数格式的字符串，利用下标就能将对应值取出来。题目返回的数字是从右往左，因此下标为倒数。
1
2
3
4
function valueAtBit(num, bit) {
  var s = num.toString(2);
     return s[s.length - bit];
 }
法②
function valueAtBit(num, bit) {
    return (num >> (bit -1)) & 1;
}
题目描述
将给定数字转换成二进制字符串。如果字符串长度不足 8 位，则在前面补 0 到满8位。 
法①：
function convertToBinary(num) {
     //转换为2进制格式
     var s = num.toString(2);
     //获得2进制数长度
     var l = s.length;
     if(l<8){
         //声明一个字符串用于补满0
         var s1 = "0000000";
         var s2 = s1.slice(0,8-l);
         s = s2+s; 
     }
     return s;
 }
法②：
function convertToBinary(num) {
    var res = num.toString(2);
    return res.length > 8 ? res : ('00000000' + res).slice(-8);
}
给定字符串 str，检查其是否包含连续重复的字母（a-zA-Z），包含返回 true，否则返回 false 
function containsRepeatingLetter(str) {
     return /([a-zA-Z])\1/.test(str);
 }
[问答题|10分]
题目描述
[附加题] 请实现下面的自定义事件 Event 对象的接口，功能见注释(测试1)该 Event 对象的接口需要能被其他对象拓展复用(测试2)// 测试1
Event.on('test', function (result) {
console.log(result);
});
Event.on('test', function () {
console.log('test');
});
Event.emit('test', 'hello world'); // 输出 'hello world' 和 'test'
// 测试2
var person1 = {};
var person2 = {};
Object.assign(person1, Event);
Object.assign(person2, Event);
person1.on('call1', function () {
console.log('person1');
});
person2.on('call2', function () {
console.log('person2');
});
person1.emit('call1'); // 输出 'person1'
person1.emit('call2'); // 没有输出
person2.emit('call1'); // 没有输出
person2.emit('call2'); // 输出 'person2' var Event = {
// 通过on接口监听事件eventName
// 如果事件eventName被触发，则执行callback回调函数
on: function (eventName, callback) {
//你的代码
},
// 触发事件 eventName
emit: function (eventName) {
//你的代码
}
};
答案：
var Event = {
    // 通过on接口监听事件eventName
    // 如果事件eventName被触发，则执行callback回调函数
    on: function (eventName, callback) {
        //你的代码
        if(!this.handles){
            //this.handles={};
            Object.defineProperty(this, "handles", {
                value: {},
                enumerable: false,
                configurable: true,
                writable: true
            })
        }
       
       if(!this.handles[eventName]){
            this.handles[eventName]=[];
       }
       this.handles[eventName].push(callback);
    },
    // 触发事件 eventName
    emit: function (eventName) {
        //你的代码
       if(this.handles[arguments[0]]){
           for(var i=0;i<this.handles[arguments[0]].length;i++){
               this.handles[arguments[0]][i](arguments[1]);
           }
       }
    }
};
答案2：
var Event = {
    on: function (eventName, callback) {
        if (!this[eventName]) {
            this[eventName] = [];
        }
        this[eventName].push(callback);
    },
    emit: function (eventName) {
        var params = arguments.length > 1 ? Array.prototype.slice.call(arguments, 1) : [];
        if (this[eventName]) {
            Array.prototype.forEach.call(this[eventName], function (item) {
                item.apply(null, params);
                //关键地方,appaly改变当前的执行环境
            });
        }
    }
}


Http中200、302、304、404和500等响应状态码所表示的意义？
200:访问成功（表示一切正常，返回的是正常请求结果）
302：临时重定向（指出被请求的文档已被临时移动到别处，此文档的新的URL在Location响应头中给出）
304：未修改（表示客户机缓存的版本是最新的，客户机应该继续使用它。）
404：访问的文件不存在（服务器上不存在客户机所请求的资源）
500：内部服务器错误（服务器端的CGI、ASP、JSP等程序发生错误）
题目描述
获取 url 中的参数
1. 指定参数名称，返回该参数的值 或者 空字符串
2. 不指定参数名称，返回全部的参数对象 或者 {}
3. 如果存在多个同名参数，则返回数组 
function getUrlParam(sUrl,sKey){
    var result = {};
    sUrl.replace(/\??(\w+)=(\w+)&?/g,function(a,k,v){
        if(result[k] !== void 0){
            var t = result[k];
            result[k] = [].concat(t,v);
        }else{
            result[k] = v;
        }
    });
    if(sKey === void 0){
        return result;
    }else{
        return result[sKey] || '';
    }
}

根据包名，在指定空间中创建对象 
输入描述:
namespace({a: {test: 1, b: 2}}, 'a.b.c.d')


输出描述:
{a: {test: 1, b: {c: {d: {}}}}}
function namespace(oNamespace, sPackage) {
    if(sPackage.length>0){
        var val=sPackage.substring(0,1);
        if(!oNamespace[val]){
            oNamespace[val]={};
        }
        arguments.callee(oNamespace[val],sPackage.substring(sPackage.indexOf(val)+2,sPackage.length));
        return oNamespace;
    }else{
        return;
    }
}
JavaScript异步编程的四种方法
1.回调函数
f1(f2);
回调函数是异步编程的基本方法。其优点是易编写、易理解和易部署；缺点是不利于代码的阅读和维护，各个部分之间高度耦合 （Coupling），流程比较混乱，而且每个任务只能指定一个回调函数。
2.事件监听
f1.on('done',f2);
事件监听即采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。其优点是易理解，可以绑定多个事件，每个事件可以指定多个回调函数，可以去耦合， 有利于实现模块化；缺点是整个程序都要变成事件驱动型，运行流程会变得不清晰。
3.  发布/订阅
f1: jQuery.publish("done");
f2: jQuery.subscribe("done", f2);
假定存在一个"信号中心"，某个任务执行完成，就向信号中心"发布"（publish）一个信号，其他任务可以向信号中心"订阅"（subscribe）这个信号，从而知道什么时候自己可以开始执行，这就叫做 "发布/订阅模式" （publish-subscribe pattern），又称 "观察者模式" （observer pattern）。该 方法的性质与"事件监听"类似，但其优势在于可以 通过查看"消息中心"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。
4.promise对象
f1().then(f2);
Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供 统一接口 ；思想是， 每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。其优点是回调函数是链式写法，程序的流程非常清晰，而且有一整套的配套方法， 可以实现许多强大的功能，如指定多个回调函数、指定发生错误时的回调函数， 如果一个任务已经完成，再添加回调函数，该回调函数会立即执行，所以不用担心是否错过了某个事件或信号；缺点就是编写和理解相对比较难。
